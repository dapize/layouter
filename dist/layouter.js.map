{"version":3,"sources":["polyfills.js","utils.js","constructor.js","methods.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"layouter.js","sourcesContent":["if (typeof Object.assign !== 'function') {\r\n  Object.defineProperty(Object, 'assign', {\r\n    value: function assign(target, varArgs) {\r\n      'use strict';\r\n      if (target === null) throw new TypeError('Cannot convert undefined or null to object');\r\n\r\n      let to = Object(target);\r\n      let index;\r\n      const nArguments = arguments.length;\r\n      let nextSource;\r\n      for (index = 1; index < nArguments; index++) {\r\n        nextSource = arguments[index];\r\n        if (nextSource != null) {\r\n          for (var nextKey in nextSource) {\r\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\r\n              to[nextKey] = nextSource[nextKey];\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return to;\r\n    },\r\n    writable: true,\r\n    configurable: true,\r\n  });\r\n};","/**\r\n * Utilidades varias\r\n * @namespace uLayouter\r\n * @property {Object} processors Lista de procesadores disponibles, junto a su método y regla css\r\n * @property {Object} flexpv Equivalencias de las propiedades y valores de flexbox.\r\n * @property {Object} replaceList Lista de caracteres a reemplazar para el nombre de las clases\r\n */\r\nconst uLayouter = {\r\n\r\n  /**\r\n   * Obtiene el width y las columnas de los breakpoints.\r\n   * @memberof uLayouter\r\n   * @param {Object} objBps Objeto de los breakPoints\r\n   * @param {String} propName Nombre de la propiedad\r\n   */\r\n  getNums: function (objBps, propName) {\r\n    const sizes = {};\r\n    Object.keys(objBps).forEach(function (bp) {\r\n      sizes[bp] = propName === 'width' && objBps[bp].direct ? 0 : objBps[bp][propName];\r\n    });\r\n    return sizes;\r\n  },\r\n\r\n  /**\r\n   * Determina si el parametro tiene o no un breakpoint designado\r\n   * @memberof uLayouter\r\n   * @param {String} param Parametro\r\n   * @returns {Boolean}\r\n   */\r\n  haveBreakPoint: function (param) {\r\n    return param.indexOf('@') !== -1 ? true : false;\r\n  },\r\n\r\n  /**\r\n   * Prepara el parametro de un método especificado. (EJM: cols, pad, etc)\r\n   * @memberof uLayouter\r\n   * @param {String} param Parametro de configuración sobre el método.\r\n   */\r\n  prepareParam: function (param) {\r\n    let bp;\r\n    const haveBp = this.haveBreakPoint(param);\r\n    if (haveBp) {\r\n      const bpSplited = param.split('@');\r\n      param = bpSplited[0];\r\n      bp = bpSplited[1];\r\n    } else {\r\n      bp = 'xs';\r\n    }\r\n    return {\r\n      widthBp: haveBp,\r\n      numbers: param,\r\n      breakPoints: bp\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Convierte un string a un número\r\n   * @memberof uLayouter\r\n   * @param {String} n El string que se vá a convertir a número\r\n   * @returns {Number}\r\n   */\r\n  stringToNumber: function (n) {\r\n    return typeof n === 'string' ? parseFloat(n) : n;\r\n  },\r\n\r\n  /**\r\n   * Calcula el porcentaje de un número\r\n   * @memberof uLayouter\r\n   * @param {Number} n1 Numero de donde se sacará el porcentaje\r\n   * @param {Number} n2 Número de valor máximo\r\n   */\r\n  calPercentage: function (n1, n2) {\r\n    return (n1 * 100) / n2 + '%'\r\n  },\r\n\r\n  /**\r\n   * Procesa un número, si es porcentual lo calcula, sino lo devuelve tal cual, al igual que cuando se recibe 'auto'.\r\n   * @memberof uLayouter\r\n   * @param {String} n Número a procesar\r\n   * @returns {String}\r\n   */\r\n  processedNumber: function (n) {\r\n    let nProcessed;\r\n    if (n.indexOf('/') !== -1) {\r\n      nProcessed = n.split('/');\r\n      nProcessed = this.calPercentage(this.stringToNumber(nProcessed[0]), this.stringToNumber(nProcessed[1]))\r\n    } else if (n === 'auto') {\r\n      nProcessed = 'auto'\r\n    } else if (n.indexOf('.') !== -1) {\r\n      nProcessed = n + 'px';\r\n    } else {\r\n      nProcessed = n === '0' ? n : n + 'px';\r\n    }\r\n    return nProcessed;\r\n  },\r\n\r\n  /**\r\n   * Registra en consola diferentes tipos de mensaje.\r\n   * @memberof uLayouter\r\n   * @param {Object} obj Contiene tres propiedades: 'type', 'state', 'message' y posiblemente 'data'\r\n   * \r\n   * @example\r\n   * uLayouter.debug({\r\n   *  type: 'i',\r\n   *  print: true,\r\n   *  message: 'Getting parameters of the Node:',\r\n   *  data: Node\r\n   * });\r\n   */\r\n  debug: function (obj) {\r\n    let printMessage = obj.print || false;\r\n    let cType;\r\n    switch(obj.type || 'l') {\r\n      case 'l':\r\n        cType = 'log';\r\n        break;\r\n      case 'e':\r\n        cType = 'error';\r\n        printMessage = true;\r\n        break;\r\n      case 'w':\r\n        cType = 'warn';\r\n        break;\r\n      case 'i':\r\n        cType = 'info';\r\n        break;\r\n    }\r\n    if (printMessage) {\r\n      let msgObj = Object.create(null);\r\n      msgObj.type = cType;\r\n      if (obj.message) msgObj.message = obj.message;\r\n      if (obj.data) msgObj.data = obj.data;\r\n      console[cType](msgObj);\r\n    } \r\n  },\r\n\r\n  /**\r\n   * Utilidad para retornar errores.\r\n   * @memberof uLayouter\r\n   * @param {String} name Título del Error\r\n   * @param {String} message Descripción del error\r\n   */\r\n  regError: function (name, message) {\r\n    const err = new Error();\r\n    err.name = name;\r\n    err.message = message;\r\n    return this.debug({\r\n      type: 'e',\r\n      message: err\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Lista de procesadores disponibles, junto a su método y regla css\r\n   */\r\n  processors: {\r\n    cols: {\r\n      set: 'setCols',\r\n      build: 'buildCols',\r\n      ruleCss: 'width'\r\n    },\r\n    // Paddings\r\n    pad: {\r\n      set: 'setPads',\r\n      build: 'buildPads',\r\n      ruleCss: 'padding'\r\n    },\r\n      padt: {\r\n        set: 'setPadTop',\r\n        build: 'buildPadTop',\r\n        ruleCss: 'padding-top'\r\n      },\r\n      padr: {\r\n        set: 'setPadRight',\r\n        build: 'buildPadRight',\r\n        ruleCss: 'padding-right'\r\n      },\r\n      padb: {\r\n        set: 'setPadBottom',\r\n        build: 'buildPadBottom',\r\n        ruleCss: 'padding-bottom'\r\n      },\r\n      padl: {\r\n        set: 'setPadLeft',\r\n        build: 'buildPadLeft',\r\n        ruleCss: 'padding-left'\r\n      },\r\n    // Margin\r\n    mar: {\r\n      set: 'setMars',\r\n      build: 'buildMars',\r\n      ruleCss: 'margin'\r\n    },\r\n      mart: {\r\n        set: 'setMarTop',\r\n        build: 'buildMarTop',\r\n        ruleCss: 'margin-top'\r\n      },\r\n      marr: {\r\n        set: 'setMarRight',\r\n        build: 'buildMarRight',\r\n        ruleCss: 'margin-right'\r\n      },\r\n      marb: {\r\n        set: 'setMarBottom',\r\n        build: 'buildMarBottom',\r\n        ruleCss: 'margin-bottom'\r\n      },\r\n      marl: {\r\n        set: 'setMarLeft',\r\n        build: 'buildMarLeft',\r\n        ruleCss: 'margin-left'\r\n      },\r\n    flex: {\r\n      set: 'setFlex',\r\n      build: 'buildFlex',\r\n      ruleCss: 'display: flex'\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Equivalencias de las propiedades y valores de flexbox\r\n   */\r\n  flexpv: {\r\n    jc: 'justify-content',\r\n    ai: 'align-items',\r\n    ce: 'center',\r\n    fs: 'flex-start',\r\n    fe: 'flex-end',\r\n    sb: 'space-between',\r\n    sa: 'space-around',\r\n    fw: 'flex-wrap',\r\n    nw: 'nowrap',\r\n    w: 'wrap',\r\n    wr: 'wrap-reverse',\r\n    fd: 'flex-direction',\r\n    r: 'row',\r\n    rr: 'row-reverse',\r\n    co: 'column',\r\n    cor: 'column-reverse'\r\n  },\r\n  \r\n  /**\r\n   * Crea una lista de estilos CSS apartir de breakpoints y propiedades.\r\n   * @memberof uLayouter\r\n   * @param {String} type Tipo de estilos a dar: 'cols', 'pad', 'mar' o 'flex'\r\n   * @param {Object} bps Objeto de breakpoints registrados\r\n   * @param {Object} instance La instancia creada, el objeto mismo.\r\n   */\r\n  createStyles: function (type, bps, instance) {\r\n    const sizes = instance.sizes;\r\n    const prefix = instance.prefix;\r\n    const prop = this.processors[type].ruleCss;\r\n    const styles = {};\r\n    let rule, bpSplited, bp1, bp2, direct = false, nameClass, propAndVal;\r\n    Object.keys(bps).forEach(function (bp) {\r\n      // preparing the className\r\n      nameClass = prefix + type + '-' + bps[bp].name;\r\n      nameClass = nameClass.replace(/\\//g, '\\\\/').replace(/:/g, '\\\\:').replace('@', '\\\\@').split('.').join('_');\r\n\r\n      // Property and value\r\n      if (type === 'flex') {\r\n        propAndVal = bps[bp].value + ';display: flex;';\r\n      } else {\r\n        propAndVal = prop +  ':' + bps[bp].value;\r\n      }\r\n\r\n      rule = '@media screen and ';\r\n      if (bp.indexOf('-') === -1) { // no tiene unti\r\n        if (sizes[bp]) {\r\n          rule += '(min-width: ' + sizes[bp] + 'px)';\r\n        } else {\r\n          rule = '.' + nameClass + '{' + propAndVal + '}';\r\n          direct = true;\r\n        }\r\n      } else { \r\n        bpSplited = bp.split('-');\r\n        bp1 = bpSplited[0];\r\n        if (bp1) rule += '(min-width: ' + sizes[bp1] + 'px) and ';\r\n        bp2 = bpSplited[1];\r\n        rule += '(max-width: ' + (sizes[bp2] - 1) + 'px)';\r\n      }\r\n\r\n      if (!direct) rule += '{.' + nameClass + '{' + propAndVal + '}}';\r\n      direct = false;\r\n      styles[nameClass] = rule;\r\n    });\r\n    this.debug({\r\n      type: 'i',\r\n      print: instance.debug,\r\n      message: 'Creating / Created Styles: ',\r\n      data: [bps, styles]\r\n    });\r\n    return styles;\r\n  },\r\n\r\n  /**\r\n   * Crea el scope de la hoja de estilos que se usará para designar los estilos que se crean al vuelo.\r\n   * @memberof uLayouter\r\n   * @param {Object} config Configuración determinada.\r\n   */\r\n  createScopeStyles: function (config) {\r\n    let stylesScope = document.getElementById('layouter');\r\n    if (stylesScope === null) {\r\n      stylesScope = document.createElement('style');\r\n      stylesScope.appendChild(document.createTextNode('')); // WebKit hack :(\r\n      document.body.appendChild(stylesScope);\r\n      stylesScope.id = 'layouter'\r\n    };\r\n    this.debug({\r\n      type: 'i',\r\n      print: config.debug,\r\n      message: 'Bridge layouter created and inserted in the DOM',\r\n      data: stylesScope\r\n    });\r\n    const bridge = config.bridge ? stylesScope.sheet : {\r\n      insertRule: function (ruleCss) {\r\n        stylesScope.innerHTML += '\\n' + ruleCss;\r\n      },\r\n      rules: []\r\n    };\r\n    return bridge;\r\n  },\r\n\r\n  /**\r\n   * Agrega las reglas CSS para darle estilos a los nodos\r\n   * @memberof uLayouter\r\n   * @param {Object} objStyles Objeto de reglas css junto con su nombre de clase.\r\n   * @param {Object} instance Instancia iniciada del layouter.\r\n   */\r\n  insertRules: function (objStyles, instance) {\r\n    const nodeScope = instance.scope;\r\n    const prefix = instance.prefix;\r\n    Object.keys(objStyles).forEach(function (className) {\r\n      if (!instance.styles.hasOwnProperty(prefix + className)) {\r\n        nodeScope.insertRule(objStyles[className], (nodeScope.rules ? nodeScope.rules.length : 0));\r\n        instance.styles[prefix + className] = objStyles[className];\r\n      }\r\n    });\r\n    this.debug({\r\n      type: 'i',\r\n      print: instance.debug,\r\n      message: 'Inserting Styles: ',\r\n      data: objStyles\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Lista de caracteres a reemplazar para el nombre de las clases\r\n   */\r\n  replaceList: [\r\n    ['\\/', ''],\r\n    ['\\\\', '/'],\r\n    ['/:', ':'],\r\n    ['\\\\:', ':'],\r\n    ['\\\\@', '@'],\r\n    ['/@', '@']\r\n  ],\r\n\r\n  /**\r\n   * Asignador de nombre de clases a un nodo.\r\n   * @memberof uLayouter\r\n   * @param {Array} classesNames Lista de nombres de las clases\r\n   * @param {Object} Node Nodo a donde agregar las clases\r\n   * @param {Object} instance Instancia iniciada del layouter.\r\n   */\r\n  addClasses: function (classesNames, Node, instance) {\r\n    const _this = this\r\n    classesNames.forEach(function (name) {\r\n      if (Node.classList.contains(name)) {\r\n        _this.debug({\r\n          type: 'w',\r\n          print: instance.debug,\r\n          message: \"The class name '\" + name + \"' already exists in the node and will not be added: \",\r\n          data: Node\r\n        });\r\n      } else {\r\n        // console.log('añadiendo: ' + name);\r\n        Node.classList.add(name);\r\n      }\r\n    });\r\n    this.debug({\r\n      type: 'i',\r\n      print: instance.debug,\r\n      message: 'Adding classes to the Node: ',\r\n      data: {\r\n        classesNames: classesNames,\r\n        node: Node\r\n      }\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Limpia los nombres de las clases.\r\n   * @param {Object} obj Contenedor de los nombres de clases y reglas CSS\r\n   * @returns {Object}\r\n   */\r\n  nameCleaner: function (objStyles) {\r\n    const _this = this;\r\n    const obj = {};\r\n    Object.keys(objStyles).forEach(function (name) {\r\n      let newName = name;\r\n      _this.replaceList.forEach(function (reItem) {\r\n        newName = newName.split(reItem[0]).join(reItem[1]);\r\n      });\r\n      obj[newName] = objStyles[name];\r\n    });\r\n    return obj;\r\n  },\r\n\r\n  /**\r\n   * Construye el nombre de clase y registra las reglas css.\r\n   * @memberof uLayouter\r\n   * @param {Object} data Lista de data para el procesamiento del CSS\r\n   */\r\n  buildCss: function (data) {\r\n    // creating the styles\r\n    const objStyles = this.createStyles(data.type, data.bps, data.instance);\r\n\r\n    // Inserting CSS rules\r\n    if (data.deep) this.insertRules(objStyles, data.instance);\r\n    \r\n    // name classes cleaner\r\n    return this.nameCleaner(objStyles);\r\n  },\r\n\r\n  /**\r\n   * Crea e inserta los estilos calculandolos, y tambien adiciona las clases respectivas al nodo\r\n   * @memberof uLayouter\r\n   * @param {Object} data Lista de data para el procesamiento del CSS\r\n   */\r\n  settingCss: function (data) {\r\n    // Building css stuffs\r\n    const objStyles = this.buildCss(Object.assign({deep: true}, data));\r\n  \r\n    // Adding classes\r\n    this.addClasses(Object.keys(objStyles), data.node, data.instance);\r\n  },\r\n\r\n  /**\r\n   * Construye los paddings y margenes.\r\n   * @memberof uLayouter\r\n   * @param {Object} Node Nodo Element HTML\r\n   * @param {String} type Nombre del tipo de atributo a obtener. cols, pad, mar y flex.\r\n   * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n   * @param {Object} instance Instancia actual del Layouter\r\n   */\r\n  buildPadsAndMargs: function (value, type, instance, insertStyles) {\r\n    if (value === undefined) return this.regError('Parameter Missing', \"Don't exists a value determined\");\r\n    this.debug({\r\n      type: 'i',\r\n      print: instance.debug,\r\n      message: \"Building the 'pads or margs': \" + value,\r\n    });\r\n    const _this = this;\r\n    const bpCals = {};\r\n    let paramProcessed, numbersPures, propValue, bps;\r\n    if (!Array.isArray(value)) value = value.split(' ');\r\n    value.forEach(function (param) {\r\n      paramProcessed = _this.prepareParam(param);\r\n      numbersPures = paramProcessed.numbers;\r\n      bps = paramProcessed.breakPoints;\r\n  \r\n      // processing number values\r\n      propValue = numbersPures\r\n        .split('-')\r\n        .map(function (n) {\r\n          return _this.processedNumber(n);\r\n        })\r\n        .join(' ');\r\n      if (bpCals.hasOwnProperty(bps)) {\r\n        bpCals[bps].value += ';' + propValue\r\n      } else {\r\n        bpCals[bps] = {\r\n          name: param,\r\n          value: propValue\r\n        };\r\n      }\r\n    });\r\n\r\n    // Building the classNames and the styles to use.\r\n    return this.buildCss({\r\n      type: type,\r\n      bps: bpCals,\r\n      instance: instance,\r\n      deep: (insertStyles === undefined ? true : insertStyles)\r\n    });\r\n  },\r\n  \r\n  /**\r\n   * Setea los paddings y margenes\r\n   * @memberof uLayouter\r\n   * @param {Object} Node Nodo Element HTML\r\n   * @param {String} type Nombre del tipo de atributo a obtener. cols, pad, mar y flex.\r\n   * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n   * @param {Object} instance Instancia actual del Layouter\r\n   */\r\n  padsAndMargs: function (Node, type, parameters, instance) {\r\n    if (!Node) return this.regError('Non-existent Node', \"Don't exists the Node for processing.\");\r\n    this.debug({\r\n      type: 'i',\r\n      print: instance.debug,\r\n      message: \"Processing the '\" + type + \"' to the Node:\",\r\n      data: Node\r\n    });\r\n    const params = parameters || instance.getParameters(Node);\r\n    if (!params.hasOwnProperty(type)) return this.regError('Parameter Missing', \"Don't exists the param '\" + type + \"' determined\");\r\n\r\n    // Creating, inserting, and adding classNames of rules in Node.\r\n    const objStyles = this.buildPadsAndMargs(params[type], type, instance);\r\n\r\n    // adding the classes names to the Node\r\n    this.addClasses(Object.keys(objStyles), Node, instance);\r\n\r\n    // removing param\r\n    Node.removeAttribute(type);\r\n  }\r\n};\r\n\r\n// for test with jest\r\nif (typeof exports !== 'undefined' && typeof module !== 'undefined' && module.exports) module.exports = uLayouter;","/**\r\n * Construtor maestro del sistema.\r\n * @constructor\r\n * @property {String} version Muestra la versión actual del sistema\r\n * @param {Object} config Objecto contenedor de las configuraciones.\r\n */\r\nfunction Layouter (config) {\r\n  // validation\r\n  if (!config.hasOwnProperty('breakPoints')) return uLayouter.regError('Configuration Missing', '¡configuration missing! :V');\r\n\r\n  // configs\r\n  this.prefix = config.prefix ? config.prefix + '-' : ''\r\n\r\n  // init setterss\r\n  const bps = config.breakPoints;\r\n  this.breakPoints = Object.keys(bps);\r\n  this.sizes = uLayouter.getNums(bps, 'width');\r\n  this.cols = uLayouter.getNums(bps, 'cols');\r\n  this.scope = uLayouter.createScopeStyles(Object.assign({bridge: true}, config));\r\n  this.styles = {};\r\n  this.debug = config.debug || false;\r\n};\r\n\r\nLayouter.version = '1.6.3Beta';","/**\r\n * Procesa todos los atributos de procesamiento que se tenga disponible\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n */\r\nLayouter.prototype.set = function (Node) {\r\n  if (!Node) return uLayouter.regError('Non-existent Node', \"Don't exists the Node for processing.\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Starting the 'set' of the Node:\",\r\n    data: Node\r\n  });\r\n  const params = this.getParameters(Node);\r\n  const proNames = Object.keys(params);\r\n  const _this = this;\r\n  if (proNames.length) {\r\n    proNames.forEach(function (processorName) {\r\n      _this[uLayouter.processors[processorName].set](Node, params);\r\n    });\r\n  } else {\r\n    uLayouter.regError('Parameter Missing', \"don't exists any parameter to process\")\r\n  }\r\n};\r\n\r\n/**\r\n * Procesa un objeto de designaciones que representan los atributos de un Nodo\r\n * @memberof Layouter\r\n * @param {Object} obj Contenedor de los atributos a procesar.\r\n */\r\nLayouter.prototype.build = function (obj) {\r\n  if (!Node) return uLayouter.regError('Non-existent Object', \"Don't exists the object for processing.\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Starting building the attributes:\",\r\n    data: obj\r\n  });\r\n  const rObj = {}, _this = this;\r\n  let propData;\r\n  Object.keys(obj).forEach(function (prop) {\r\n    propData = uLayouter.processors[prop];\r\n    if (propData) rObj[prop] = _this[propData.build](obj[prop])\r\n  });\r\n  return (Object.keys(rObj).length) ? rObj : false;\r\n};\r\n\r\n/**\r\n * Obtiene los parametros disponibles para procesar\r\n * @memberof Layouter\r\n * @param {Object} Nodo Nodo de donde obtener los parametros.\r\n * @returns {Object}\r\n */\r\nLayouter.prototype.getParameters = function (Node) {\r\n  const params = {};\r\n  const attrs = Node.attributes;\r\n  const paramNames = Object.keys(uLayouter.processors);\r\n  Array.prototype.forEach.call(attrs, function (attr) {\r\n    if (paramNames.indexOf(attr.name) !== -1) {\r\n      if (attr.value !== '') params[attr.name] = attr.value.trim().split(' ');\r\n    }\r\n  });\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: 'Getting / Getted parameters of the Node:',\r\n    data: {\r\n      parameters: params,\r\n      node: Node\r\n    }\r\n  });\r\n  return params;\r\n};\r\n\r\n/**\r\n * Construye las columnas requeridas, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valCols columnas a procesar\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @returns {Object}\r\n */\r\nLayouter.prototype.buildCols = function (valCols, insertStyles) {\r\n  if (valCols === undefined) return uLayouter.regError('Parameter Missing', \"Don't exists 'cols' determined\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Building the 'cols': \" + valCols,\r\n  });\r\n  const _this = this;\r\n  let cols, bp, bpCals = {};\r\n\r\n  // Getting numbers\r\n  let selectorName, propValue, paramPrepared;\r\n  if (!Array.isArray(valCols)) valCols = valCols.split(' ');\r\n  valCols.forEach(function (param) {\r\n    selectorName = param;\r\n\r\n    paramPrepared = uLayouter.prepareParam(param);\r\n    bp = paramPrepared.breakPoints;\r\n    param = paramPrepared.numbers;\r\n\r\n    if (param.indexOf('/') !== -1) {\r\n      cols = param.split('/');\r\n    } else {\r\n      if (paramPrepared.widthBp) {\r\n        if (bp.indexOf('-') === -1) {\r\n          cols = [param, _this.cols[bp]];\r\n        } else {\r\n          uLayouter.regError('SyntaxError', \"You can't determine a 'until breakpoint' when use the explicit columns max\");\r\n        }\r\n      } else {\r\n        cols = [param, _this.cols.xs];\r\n      }\r\n    }\r\n    propValue = uLayouter.calPercentage(cols[0], cols[1]);\r\n\r\n    bpCals[bp] = {\r\n      name: selectorName,\r\n      value: propValue\r\n    };\r\n  });\r\n\r\n  // Building the classNames and the styles to use.\r\n  return uLayouter.buildCss({\r\n    type: 'cols',\r\n    bps: bpCals,\r\n    instance: this,\r\n    deep: (insertStyles === undefined ? true : insertStyles)\r\n  });\r\n};\r\n\r\n/**\r\n * Asigna los estilos necesarios a un nodo referentes a las columnas determinadas\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo a donde asignar los estilos\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setCols = function (Node, parameters) {\r\n  if (!Node) return uLayouter.regError('Non-existent Node', \"Don't exists the Node for processing.\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Processing the 'cols' to the Node:\",\r\n    data: Node\r\n  });\r\n  const params = parameters || this.getParameters(Node);\r\n  if (!params.hasOwnProperty('cols')) return uLayouter.regError('Parameter Missing', \"Don't exists 'cols' determined\");\r\n\r\n  // Creating, inserting, and adding classNames of rules in Node.\r\n  const objStyles = this.buildCols(params.cols);\r\n\r\n  // adding the classes names to the Node\r\n  uLayouter.addClasses(Object.keys(objStyles), Node, this);\r\n\r\n  // removing param\r\n  Node.removeAttribute('cols');\r\n};\r\n\r\n/**\r\n * Construye los paddings requeridas, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valPads Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildPads = function (valPads, insertStyles) {\r\n  return uLayouter.buildPadsAndMargs(valPads, 'pad', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea los paddings necesarios para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setPads = function (Node, parameters) {\r\n  uLayouter.padsAndMargs(Node, 'pad', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el padding superior, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valPad Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildPadTop = function (valPad, insertStyles) {\r\n  return uLayouter.buildPadsAndMargs(valPad, 'padt', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el padding top necesario para un nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setPadTop = function (Node, parameters) {\r\n  uLayouter.padsAndMargs(Node, 'padt', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el padding derecho, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valPad Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildPadRight = function (valPad, insertStyles) {\r\n  return uLayouter.buildPadsAndMargs(valPad, 'padr', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el padding right necesario para un nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setPadRight = function (Node, parameters) {\r\n  uLayouter.padsAndMargs(Node, 'padr', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el padding inferior, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valPad Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildPadBottom = function (valPad, insertStyles) {\r\n  return uLayouter.buildPadsAndMargs(valPad, 'padb', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el padding bottom necesario para un nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setPadBottom = function (Node, parameters) {\r\n  uLayouter.padsAndMargs(Node, 'padb', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el padding izquierdo, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valPad Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildPadLeft = function (valPad, insertStyles) {\r\n  return uLayouter.buildPadsAndMargs(valPad, 'padl', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el padding left necesario para un nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setPadLeft = function (Node, parameters) {\r\n  uLayouter.padsAndMargs(Node, 'padl', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye los margenes, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMars Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMars = function (valMars, insertStyles) {\r\n  return uLayouter.buildPadsAndMargs(valMars, 'mar', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea los margins necesarios para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMars = function (Node, parameters) {\r\n  uLayouter.padsAndMargs(Node, 'mar', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el margen superior, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMar Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMarTop = function (valMar, insertStyles) {\r\n  return uLayouter.buildPadsAndMargs(valMar, 'mart', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el margin top necesario para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMarTop = function (Node, parameters) {\r\n  uLayouter.padsAndMargs(Node, 'mart', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el margen derecho, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMar Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMarRight = function (valMar, insertStyles) {\r\n  return uLayouter.buildPadsAndMargs(valMar, 'marr', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el margin right necesario para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMarRight = function (Node, parameters) {\r\n  uLayouter.padsAndMargs(Node, 'marr', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el margen inferior, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMar Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMarBottom = function (valMar, insertStyles) {\r\n  return uLayouter.buildPadsAndMargs(valMar, 'marb', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el margin bottom necesario para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMarBottom = function (Node, parameters) {\r\n  uLayouter.padsAndMargs(Node, 'marb', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el margen inferior, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMar Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMarLeft = function (valMar, insertStyles) {\r\n  return uLayouter.buildPadsAndMargs(valMar, 'marl', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el margin left necesario para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMarLeft = function (Node, parameters) {\r\n  uLayouter.padsAndMargs(Node, 'marl', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye las reglas CSS y nombre de clases referente al 'flex'.\r\n * @memberof Layouter\r\n * @param {String} valFlex columnas a procesar\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @returns {Object}\r\n */\r\nLayouter.prototype.buildFlex = function (valFlex, insertStyles) {\r\n  if (valFlex === undefined) return uLayouter.regError('Parameter Missing', \"Don't exists 'flex' determined\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Building the 'flex': \" + valFlex,\r\n  });\r\n  let bpNameS, bpCals = {};\r\n\r\n  // Getting numbers\r\n  let selectorName, paramPrepared, flexSplited,  propVal, nameProp, valProp;\r\n  if (!Array.isArray(valFlex)) valFlex = valFlex.split(' ');\r\n\r\n  valFlex.forEach(function (param) {\r\n    selectorName = param;\r\n\r\n    paramPrepared = uLayouter.prepareParam(param);\r\n    bpNameS = paramPrepared.breakPoints;\r\n    param = paramPrepared.numbers;\r\n\r\n    flexSplited = param.split(':');\r\n    nameProp = flexSplited[0];\r\n    if (uLayouter.flexpv.hasOwnProperty(nameProp)) {\r\n      valProp = flexSplited[1];\r\n      if (uLayouter.flexpv.hasOwnProperty(valProp)) {\r\n        propVal = uLayouter.flexpv[nameProp] + ':' + uLayouter.flexpv[flexSplited[1]]\r\n      } else {\r\n        return uLayouter.regError('Non-existent Alias', \"Don't exists the alias '\" + valProp + \"' in Flex vault.\");\r\n      }\r\n    } else {\r\n      return uLayouter.regError('Non-existent Alias', \"Don't exists the alias '\" + nameProp + \"' in Flex vault.\");\r\n    }\r\n\r\n    if (bpCals.hasOwnProperty(bpNameS)) {\r\n      if (selectorName.indexOf('@') !== 1) selectorName = selectorName.split('@')[0];\r\n      bpCals[bpNameS].name = bpCals[bpNameS].name.split('@')[0] + '-' + selectorName + '@' + bpNameS;\r\n      bpCals[bpNameS].value += ';' + propVal;\r\n    } else {\r\n      bpCals[bpNameS] = {\r\n        name: selectorName,\r\n        value: propVal\r\n      };\r\n    }\r\n  });\r\n\r\n  // Building the classNames and the styles to use.\r\n  return uLayouter.buildCss({\r\n    type: 'flex',\r\n    bps: bpCals,\r\n    instance: this,\r\n    deep: (insertStyles === undefined ? true : insertStyles)\r\n  });\r\n};\r\n\r\n/**\r\n * Setea la propiedad Flex y las reglas designadas\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setFlex = function (Node, parameters) {\r\n  if (!Node) return uLayouter.regError('Non-existent Node', \"Don't exists the Node for processing.\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Processing the 'flex' parameter to the Node:\",\r\n    data: Node\r\n  });\r\n  const params = parameters || this.getParameters(Node);\r\n  if (!params.hasOwnProperty('flex')) return uLayouter.regError('Parameter Missing', \"Don't exists 'flex' determinated.\");\r\n\r\n  // Creating, inserting, and adding classNames of rules in Node.\r\n  const objStyles = this.buildFlex(params.flex);\r\n\r\n  // adding the classes names to the Node\r\n  uLayouter.addClasses(Object.keys(objStyles), Node, this);\r\n\r\n  // removing param\r\n  Node.removeAttribute('flex');\r\n};"]}