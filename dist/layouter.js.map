{"version":3,"sources":["polyfills.js","utils.js","constructor.js","methods.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"layouter.js","sourcesContent":["if (typeof Object.assign !== 'function') {\r\n  Object.defineProperty(Object, 'assign', {\r\n    value: function assign(target, varArgs) {\r\n      'use strict';\r\n      if (target === null) throw new TypeError('Cannot convert undefined or null to object');\r\n\r\n      let to = Object(target);\r\n      let index;\r\n      const nArguments = arguments.length;\r\n      let nextSource;\r\n      for (index = 1; index < nArguments; index++) {\r\n        nextSource = arguments[index];\r\n        if (nextSource != null) {\r\n          for (var nextKey in nextSource) {\r\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\r\n              to[nextKey] = nextSource[nextKey];\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return to;\r\n    },\r\n    writable: true,\r\n    configurable: true,\r\n  });\r\n};","/**\r\n * Utilidades varias\r\n * @namespace uLayouter\r\n * @property {Object} processors Lista de procesadores disponibles, junto a su método y regla css\r\n * @property {Object} flexpv Equivalencias de las propiedades y valores de flexbox.\r\n * @property {Object} replaceList Lista de caracteres a reemplazar para el nombre de las clases\r\n */\r\nconst uLayouter = {\r\n  /**\r\n   * Obtiene el width y las columnas de los breakpoints.\r\n   * @memberof uLayouter\r\n   * @param {Object} objBps Objeto de los breakPoints\r\n   * @param {String} propName Nombre de la propiedad\r\n   */\r\n  getNums: function (objBps, propName) {\r\n    const sizes = {};\r\n    Object.keys(objBps).forEach(function (bp) {\r\n      sizes[bp] = propName === 'width' && objBps[bp].direct ? 0 : objBps[bp][propName];\r\n    });\r\n    return sizes;\r\n  },\r\n\r\n  /**\r\n   * Devuelve un array ordenando los Breakpoints de menor a mayor, dependiendo su width\r\n   * @param {Object} bps Objeto breakpoints definidos en la configuración de la instancia.\r\n   * @returns {Array}\r\n   */\r\n  getBpsOrdered: function (bps) {\r\n    const objBps = this.getNums(bps, 'width');\r\n    const arrBps = Object.keys(bps);\r\n    return arrBps\r\n      .map(function (bp) {\r\n        return objBps[bp];\r\n      })\r\n      .sort(function(a, b) {\r\n        return a - b;\r\n      })\r\n      .map(function (width) {\r\n        return arrBps.filter(function (iBp) {\r\n          return objBps[iBp] === width\r\n        })[0]\r\n      })\r\n  },\r\n\r\n  /**\r\n   * Determina si el parametro tiene o no un breakpoint designado\r\n   * @memberof uLayouter\r\n   * @param {String} param Parametro\r\n   * @returns {Boolean}\r\n   */\r\n  haveBreakPoint: function (param) {\r\n    return param.indexOf('@') !== -1;\r\n  },\r\n\r\n  /**\r\n   * Sirve para obtener el breakpoint declarado con la propiedad 'direct'.\r\n   * @param {Object} objBps Objecto contenedor con los breakpoints pasados en la configuración.\r\n   */\r\n  getDirectBp: function (objBps) {\r\n    const bpDirect = Object.keys(objBps).filter(function (iBp) {\r\n      return objBps[iBp].direct\r\n    });\r\n    return bpDirect.length ? bpDirect[0] : false;\r\n  },\r\n\r\n  /**\r\n   * Prepara el parametro de un método especificado. (EJM: cols, pad, etc)\r\n   * @memberof uLayouter\r\n   * @param {String} param Parametro de configuración sobre el método.\r\n   * @param {Object} objBps Objeto de Breakpoints definidos en la configuración base.\r\n   */\r\n  prepareParam: function (param, objBps) {\r\n    let bp;\r\n    let argParam = param;\r\n    let important = false;\r\n    const haveBp = this.haveBreakPoint(argParam);\r\n    if (haveBp) {\r\n      const bpSplited = argParam.split('@');\r\n      argParam = bpSplited[0];\r\n      bp = bpSplited[1];\r\n    } else {\r\n      const directBp = this.getDirectBp(objBps);\r\n      if (directBp) {\r\n        bp = directBp;\r\n      } else {\r\n        return this.regError(\"without 'direct' breakpoint\", \"Don't exists a breakpoint with 'direct' designation.\");\r\n      }\r\n    };\r\n\r\n    if (param.indexOf('!') !== -1) {\r\n      important = true;\r\n      bp = bp.replace(/!/g, '');\r\n      argParam = argParam.replace(/!/g, '');\r\n    };\r\n\r\n    return {\r\n      widthBp: haveBp,\r\n      numbers: argParam,\r\n      breakPoints: bp,\r\n      important: important\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Convierte un string a un número\r\n   * @memberof uLayouter\r\n   * @param {String} n El string que se vá a convertir a número\r\n   * @returns {Number}\r\n   */\r\n  stringToNumber: function (n) {\r\n    return typeof n === 'string' ? parseFloat(n) : n;\r\n  },\r\n\r\n  /**\r\n   * Calcula el porcentaje de un número\r\n   * @memberof uLayouter\r\n   * @param {Number} n1 Numero de donde se sacará el porcentaje\r\n   * @param {Number} n2 Número de valor máximo\r\n   */\r\n  calPercentage: function (n1, n2) {\r\n    return (n1 * 100) / n2 + '%'\r\n  },\r\n\r\n  /**\r\n   * Procesa un número, si es porcentual lo calcula, sino lo devuelve tal cual, al igual que cuando se recibe 'auto'.\r\n   * @memberof uLayouter\r\n   * @param {String} n Número a procesar\r\n   * @returns {String}\r\n   */\r\n  processedNumber: function (n) {\r\n    let nProcessed;\r\n    if (n.indexOf('/') !== -1) {\r\n      nProcessed = n.split('/');\r\n      nProcessed = this.calPercentage(this.stringToNumber(nProcessed[0]), this.stringToNumber(nProcessed[1]))\r\n    } else if (n === 'auto') {\r\n      nProcessed = 'auto'\r\n    } else if (n.indexOf('.') !== -1) {\r\n      nProcessed = n + 'px';\r\n    } else {\r\n      nProcessed = n === '0' ? n : n + 'px';\r\n    }\r\n    return nProcessed;\r\n  },\r\n\r\n  /**\r\n   * Registra en consola diferentes tipos de mensaje.\r\n   * @memberof uLayouter\r\n   * @param {Object} obj Contiene tres propiedades: 'type', 'state', 'message' y posiblemente 'data'\r\n   * \r\n   * @example\r\n   * uLayouter.debug({\r\n   *  type: 'i',\r\n   *  print: true,\r\n   *  message: 'Getting parameters of the Node:',\r\n   *  data: Node\r\n   * });\r\n   */\r\n  debug: function (obj) {\r\n    let printMessage = obj.print || false;\r\n    let cType;\r\n    switch(obj.type || 'l') {\r\n      case 'l':\r\n        cType = 'log';\r\n        break;\r\n      case 'e':\r\n        cType = 'error';\r\n        printMessage = true;\r\n        break;\r\n      case 'w':\r\n        cType = 'warn';\r\n        break;\r\n      case 'i':\r\n        cType = 'info';\r\n        break;\r\n    }\r\n    if (printMessage) {\r\n      let msgObj = Object.create(null);\r\n      msgObj.type = cType;\r\n      if (obj.message) msgObj.message = obj.message;\r\n      if (obj.data) msgObj.data = obj.data;\r\n      console[cType](msgObj);\r\n    } \r\n  },\r\n\r\n  /**\r\n   * Utilidad para retornar errores.\r\n   * @memberof uLayouter\r\n   * @param {String} name Título del Error\r\n   * @param {String} message Descripción del error\r\n   */\r\n  regError: function (name, message) {\r\n    const err = new Error();\r\n    err.name = name;\r\n    err.message = message;\r\n    return this.debug({\r\n      type: 'e',\r\n      message: err\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Lista de procesadores disponibles, junto a su método y regla css\r\n   */\r\n  processors: {\r\n    cols: {\r\n      set: 'setCols',\r\n      build: 'buildCols',\r\n      ruleCss: 'width'\r\n    },\r\n    // Paddings\r\n    pad: {\r\n      set: 'setPads',\r\n      build: 'buildPads',\r\n      ruleCss: 'padding'\r\n    },\r\n      padt: {\r\n        set: 'setPadTop',\r\n        build: 'buildPadTop',\r\n        ruleCss: 'padding-top'\r\n      },\r\n      padr: {\r\n        set: 'setPadRight',\r\n        build: 'buildPadRight',\r\n        ruleCss: 'padding-right'\r\n      },\r\n      padb: {\r\n        set: 'setPadBottom',\r\n        build: 'buildPadBottom',\r\n        ruleCss: 'padding-bottom'\r\n      },\r\n      padl: {\r\n        set: 'setPadLeft',\r\n        build: 'buildPadLeft',\r\n        ruleCss: 'padding-left'\r\n      },\r\n    // Margin\r\n    mar: {\r\n      set: 'setMars',\r\n      build: 'buildMars',\r\n      ruleCss: 'margin'\r\n    },\r\n      mart: {\r\n        set: 'setMarTop',\r\n        build: 'buildMarTop',\r\n        ruleCss: 'margin-top'\r\n      },\r\n      marr: {\r\n        set: 'setMarRight',\r\n        build: 'buildMarRight',\r\n        ruleCss: 'margin-right'\r\n      },\r\n      marb: {\r\n        set: 'setMarBottom',\r\n        build: 'buildMarBottom',\r\n        ruleCss: 'margin-bottom'\r\n      },\r\n      marl: {\r\n        set: 'setMarLeft',\r\n        build: 'buildMarLeft',\r\n        ruleCss: 'margin-left'\r\n      },\r\n    flex: {\r\n      set: 'setFlex',\r\n      build: 'buildFlex',\r\n      ruleCss: 'display: flex'\r\n    },\r\n\r\n    mw: {\r\n      set: 'setMaxWidth',\r\n      build: 'buildMaxWidth',\r\n      ruleCss: 'max-width'\r\n    },\r\n    mh: {\r\n      set: 'setMaxHeight',\r\n      build: 'buildMaxHeight',\r\n      ruleCss: 'max-height'\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Equivalencias de las propiedades y valores de flexbox\r\n   */\r\n  flexpv: {\r\n    jc: 'justify-content',\r\n    ai: 'align-items',\r\n    ce: 'center',\r\n    fs: 'flex-start',\r\n    fe: 'flex-end',\r\n    sb: 'space-between',\r\n    sa: 'space-around',\r\n    fw: 'flex-wrap',\r\n    nw: 'nowrap',\r\n    w: 'wrap',\r\n    wr: 'wrap-reverse',\r\n    fd: 'flex-direction',\r\n    r: 'row',\r\n    rr: 'row-reverse',\r\n    co: 'column',\r\n    cor: 'column-reverse',\r\n    fg: 'flex-grow',\r\n    fh: 'flex-shrink',\r\n    as: 'align-self',\r\n    or: 'order',\r\n    au: 'auto',\r\n    st: 'stretch',\r\n    bl: 'baseline',\r\n    in: 'initial',\r\n    ih: 'inherit'\r\n  },\r\n\r\n  /**\r\n   * Define los atributos de flex que no dependen del mismo.\r\n   */\r\n  flexAttrsSelf: ['fg', 'fh', 'or'],\r\n  \r\n  /**\r\n   * Crea el scope para un BP determinado.\r\n   * @memberof uLayouter\r\n   * @param {Object} config Configuración determinada.\r\n   * @param {String} bp El Break Point, dependiendo de la definición sería: xs, sm, md, lg u otros.\r\n   * @param {String} insertionType Define el tipo de inserción a realizar.\r\n   * @param {HTMLElement} node El nodo base desde donde se insertará el nuevo nodo de estilos (ya sea antes, despues, o como nuevo hermano).\r\n   * @returns {Object}\r\n   */\r\n  createScopeStyles: function (config, bp, insertionType, node) {\r\n    let stylesScope = document.getElementById('layouter-' + bp);\r\n    if (!stylesScope) {\r\n      stylesScope = document.createElement('style');\r\n      stylesScope.appendChild(document.createTextNode('')); // WebKit hack :(\r\n      switch(insertionType) {\r\n        case 'before':\r\n          node.parentNode.insertBefore(stylesScope, node)\r\n          break;\r\n        case 'after':\r\n          const nodeParent = node.parentNode;\r\n          node.nextSibling ? nodeParent.insertBefore(stylesScope, node.nextSibling) : nodeParent.appendChild(stylesScope);\r\n          break;\r\n        case 'append':\r\n          node.appendChild(stylesScope);\r\n          break;\r\n      }\r\n      stylesScope.id = 'layouter-' + bp;\r\n    };\r\n    this.debug({\r\n      type: 'i',\r\n      print: config.debug,\r\n      message: 'Bridge layouter created and inserted in the DOM',\r\n      data: stylesScope\r\n    });\r\n    let bridge;\r\n    if (config.bridge) {\r\n      bridge = {\r\n        method: stylesScope.sheet,\r\n        node: stylesScope\r\n      }\r\n    } else {\r\n      bridge = {\r\n        method: {\r\n          insertRule: function (ruleCss) {\r\n            stylesScope.appendChild(document.createTextNode(ruleCss))\r\n          },\r\n          rules: [],\r\n        },\r\n        node: stylesScope\r\n      }\r\n    }\r\n    return bridge;\r\n  },\r\n\r\n  /**\r\n   * Crea los scopes correspondientes para cada breakpoint definido, de forma ordenada, eso es muy importante.\r\n   * @param {Object} config Objeto base de configuración que se pasa en la instancia.\r\n   */\r\n  createScopesStyles: function (config) {\r\n    const arrBps = this.getBpsOrdered(config.breakPoints);\r\n    const scopes = {};\r\n    const _this = this;\r\n    arrBps.forEach(function (bp) {\r\n      scopes[bp] = _this.createScopeStyles(config, bp, 'append', document.body);\r\n    });\r\n    return scopes;\r\n  },\r\n\r\n  /**\r\n   * Obtiene el los métodos del nodo 'style' desde un 'className'. \r\n   * @param {String} className Nombre de la clase CSS\r\n   * @param {Object} instance Instancia de la librería.\r\n   */\r\n  getScopeByclassName: function (className, instance) {\r\n    const bps = instance.breakPoints;\r\n    const nameClass = className.replace(/!/g, '');\r\n    const atIndex = nameClass.indexOf('@');\r\n\r\n    // Haven´t a BP designed\r\n    if (atIndex === -1) {\r\n      const directBp = this.getDirectBp(bps);\r\n      return instance.scope[directBp];  \r\n    };\r\n\r\n    // Have a BP designed, a normal BP.\r\n    const bp = nameClass.substring(atIndex + 1);\r\n    if (bp.indexOf('-') === -1) return instance.scope[bp]; // A simple BP, not compound (like this: 13/15@sm-md).\r\n\r\n    // For the nexts types insertions\r\n    const smallConfig = {\r\n      bridge: instance.bridge,\r\n      debug: instance.debug\r\n    };\r\n\r\n    // A BP until. Example 13/15@-md\r\n    if (bp.substring(0, 1) === '-') {\r\n      if (instance.scope.hasOwnProperty(bp)) return instance.scope[bp]; // exists the Scope.\r\n      const bpUntil = bp.substring(1);\r\n      instance.scope[bp] = this.createScopeStyles(smallConfig, bp, 'before', instance.scope[bpUntil].node);\r\n      return instance.scope[bp]; // returning a new scope created\r\n    }\r\n\r\n    // A BP from and until (a BP Compount). Example: Example 13/15@sm-md\r\n    if (instance.scope.hasOwnProperty(bp)) return instance.scope[bp]; // exists the Scope.\r\n    \r\n    const fromBp = bp.split('-')[0];\r\n    instance.scope[bp] = this.createScopeStyles(smallConfig, bp, 'after', instance.scope[fromBp].node);\r\n    return instance.scope[bp]; // returning a new scope compounted created\r\n  },\r\n\r\n  /**\r\n   * Lista de caracteres a reemplazar para el nombre de las clases\r\n   */\r\n  replaceList: [\r\n    ['\\/', ''],\r\n    ['\\\\', '/'],\r\n    ['/:', ':'],\r\n    ['\\\\:', ':'],\r\n    ['\\\\@', '@'],\r\n    ['/@', '@']\r\n  ],\r\n\r\n  /**\r\n   * Asignador de nombre de clases a un nodo.\r\n   * @memberof uLayouter\r\n   * @param {Array} classesNames Lista de nombres de las clases\r\n   * @param {Object} Node Nodo a donde agregar las clases\r\n   * @param {Object} instance Instancia iniciada del layouter.\r\n   */\r\n  addClasses: function (classesNames, Node, instance) {\r\n    const _this = this\r\n    classesNames.forEach(function (name) {\r\n      if (Node.classList.contains(name)) {\r\n        _this.debug({\r\n          type: 'w',\r\n          print: instance.debug,\r\n          message: \"The class name '\" + name + \"' already exists in the node and will not be added: \",\r\n          data: Node\r\n        });\r\n      } else {\r\n        Node.classList.add(name);\r\n      }\r\n    });\r\n    this.debug({\r\n      type: 'i',\r\n      print: instance.debug,\r\n      message: 'Adding classes to the Node: ',\r\n      data: {\r\n        classesNames: classesNames,\r\n        node: Node\r\n      }\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Limpia los nombres de las clases.\r\n   * @param {Object} obj Contenedor de los nombres de clases y reglas CSS\r\n   * @returns {Object}\r\n   */\r\n  nameCleaner: function (objStyles) {\r\n    const _this = this;\r\n    const obj = {};\r\n    Object.keys(objStyles).forEach(function (name) {\r\n      let newName = name;\r\n      _this.replaceList.forEach(function (reItem) {\r\n        newName = newName.split(reItem[0]).join(reItem[1]);\r\n      });\r\n      obj[newName] = objStyles[name];\r\n    });\r\n    return obj;\r\n  },\r\n\r\n  /**\r\n   * Crea una lista de estilos CSS apartir de breakpoints y propiedades.\r\n   * @memberof uLayouter\r\n   * @param {String} type Tipo de estilos a dar: 'cols', 'pad', 'mar' o 'flex'\r\n   * @param {Object} bps Objeto de breakpoints registrados\r\n   * @param {Object} instance La instancia creada, el objeto mismo.\r\n   */\r\n  createStyles: function (type, bps, instance) {\r\n    const sizes = instance.sizes;\r\n    const prefix = instance.prefix;\r\n    const prop = this.processors[type].ruleCss;\r\n    const styles = {};\r\n    let rule, bpSplited, bp1, bp2, direct = false, nameClass, propAndVal, shortNameClass, pureShortName;\r\n    const _this = this;\r\n    Object.keys(bps).forEach(function (bp) {\r\n      // preparing the className\r\n      shortNameClass = bps[bp].name;\r\n      nameClass = prefix + type + '-' + shortNameClass;\r\n      nameClass = nameClass.replace(/\\//g, '\\\\/').replace(/:/g, '\\\\:').replace('@', '\\\\@').split('.').join('_');\r\n\r\n      // Property and value\r\n      if (type === 'flex') {\r\n        propAndVal = bps[bp].value;\r\n        pureShortName = shortNameClass.split(':')[0];\r\n        if (_this.flexAttrsSelf.indexOf(pureShortName) === -1 && pureShortName !== 'as') {\r\n          propAndVal += shortNameClass.indexOf('!') !== -1 ? ';display:flex !important;' : ';display:flex;';\r\n        }\r\n      } else {\r\n        propAndVal = prop +  ':' + bps[bp].value;\r\n      }\r\n\r\n      rule = '@media screen and ';\r\n      if (bp.indexOf('-') === -1) { // no tiene until\r\n        if (sizes[bp]) {\r\n          rule += '(min-width: ' + sizes[bp] + 'px)';\r\n        } else {\r\n          rule = '.' + nameClass.replace(/!/g, '\\\\!') + '{' + propAndVal + '}';\r\n          direct = true;\r\n        }\r\n      } else { \r\n        bpSplited = bp.split('-');\r\n        bp1 = bpSplited[0];\r\n        if (bp1) rule += '(min-width: ' + sizes[bp1] + 'px) and ';\r\n        bp2 = bpSplited[1];\r\n        rule += '(max-width: ' + (sizes[bp2] - 1) + 'px)';\r\n      }\r\n\r\n      if (!direct) rule += '{.' + nameClass.replace(/!/g, '\\\\!') + '{' + propAndVal + '}}';\r\n      direct = false;\r\n      styles[nameClass] = rule;\r\n    });\r\n    this.debug({\r\n      type: 'i',\r\n      print: instance.debug,\r\n      message: 'Creating / Created Styles: ',\r\n      data: [bps, styles]\r\n    });\r\n    return styles;\r\n  },\r\n\r\n  /**\r\n   * Agrega las reglas CSS para darle estilos a los nodos\r\n   * @memberof uLayouter\r\n   * @param {Object} objStyles Objeto de reglas css junto con su nombre de clase.\r\n   * @param {Object} instance Instancia iniciada del layouter.\r\n   */\r\n  insertRules: function (objStyles, instance) {\r\n    const _this = this;\r\n    Object.keys(objStyles).forEach(function (className) {\r\n      if (!instance.styles.hasOwnProperty(className)) {\r\n        let nodeScope = _this.getScopeByclassName(className, instance);\r\n        if (nodeScope !== undefined) {\r\n          nodeScope.method.insertRule(objStyles[className], (nodeScope.method.rules ? nodeScope.method.rules.length : 0));\r\n          instance.styles[className] = objStyles[className]; // saving in styles vault\r\n        } else {\r\n          _this.regError('Dont exists scope', \"Don't exists a scope valid for '\" + className + \"'\");\r\n        }\r\n      }\r\n    });\r\n    this.debug({\r\n      type: 'i',\r\n      print: instance.debug,\r\n      message: 'Inserting Styles: ',\r\n      data: objStyles\r\n    });\r\n  },\r\n\r\n  /**\r\n   * Construye el nombre de clase y registra las reglas css.\r\n   * @memberof uLayouter\r\n   * @param {Object} data Lista de data para el procesamiento del CSS\r\n   */\r\n  buildCss: function (data) {\r\n    // creating the styles\r\n    const objStyles = this.createStyles(data.type, data.bps, data.instance);\r\n\r\n    // Inserting CSS rules\r\n    if (data.deep) this.insertRules(objStyles, data.instance);\r\n\r\n    // name classes cleaner\r\n    return this.nameCleaner(objStyles);\r\n  },\r\n\r\n  /**\r\n   * Crea e inserta los estilos calculandolos, y tambien adiciona las clases respectivas al nodo\r\n   * @memberof uLayouter\r\n   * @param {Object} data Lista de data para el procesamiento del CSS\r\n   */\r\n  settingCss: function (data) {\r\n    // Building css stuffs\r\n    const objStyles = this.buildCss(Object.assign({deep: true}, data));\r\n  \r\n    // Adding classes\r\n    this.addClasses(Object.keys(objStyles), data.node, data.instance);\r\n  },\r\n\r\n  /**\r\n   * Construye los paddings y margenes.\r\n   * @memberof uLayouter\r\n   * @param {Object} Node Nodo Element HTML\r\n   * @param {String} type Nombre del tipo de atributo a obtener. cols, pad, mar y flex.\r\n   * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n   * @param {Object} instance Instancia actual del Layouter\r\n   */\r\n  buildPadsMargsMaxs: function (value, type, instance, insertStyles) {\r\n    if (value === undefined) return this.regError('Parameter Missing', \"Don't exists a value determined\");\r\n    this.debug({\r\n      type: 'i',\r\n      print: instance.debug,\r\n      message: \"Building the 'pads or margs': \" + value,\r\n    });\r\n    const _this = this;\r\n    const bpCals = {};\r\n    let paramProcessed, numbersPures, propValue, bps;\r\n    if (!Array.isArray(value)) value = value.split(' ');\r\n    value.forEach(function (param) {\r\n      paramProcessed = _this.prepareParam(param, instance.breakPoints);\r\n      numbersPures = paramProcessed.numbers;\r\n      bps = paramProcessed.breakPoints;\r\n  \r\n      // processing number values\r\n      propValue = numbersPures\r\n        .split('-')\r\n        .map(function (n) {\r\n          return _this.processedNumber(n);\r\n        })\r\n        .join(' ');\r\n      if (paramProcessed.important) propValue += ' !important';\r\n      if (bpCals.hasOwnProperty(bps)) {\r\n        bpCals[bps].value += ';' + propValue\r\n      } else {\r\n        bpCals[bps] = {\r\n          name: param,\r\n          value: propValue\r\n        };\r\n      }\r\n    });\r\n\r\n    // Building the classNames and the styles to use.\r\n    return this.buildCss({\r\n      type: type,\r\n      bps: bpCals,\r\n      instance: instance,\r\n      deep: (insertStyles === undefined ? true : insertStyles)\r\n    });\r\n  },\r\n  \r\n  /**\r\n   * Setea los paddings y margenes\r\n   * @memberof uLayouter\r\n   * @param {Object} Node Nodo Element HTML\r\n   * @param {String} type Nombre del tipo de atributo a obtener. cols, pad, mar y flex.\r\n   * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n   * @param {Object} instance Instancia actual del Layouter\r\n   */\r\n  setPadsMargsMaxs: function (Node, type, parameters, instance) {\r\n    if (!Node) return this.regError('Non-existent Node', \"Don't exists the Node for processing.\");\r\n    this.debug({\r\n      type: 'i',\r\n      print: instance.debug,\r\n      message: \"Processing the '\" + type + \"' to the Node:\",\r\n      data: Node\r\n    });\r\n    const params = parameters || instance.getParameters(Node);\r\n    if (!params.hasOwnProperty(type)) return this.regError('Parameter Missing', \"Don't exists the param '\" + type + \"' determined\");\r\n\r\n    // Creating, inserting, and adding classNames of rules in Node.\r\n    const objStyles = this.buildPadsMargsMaxs(params[type], type, instance);\r\n\r\n    // adding the classes names to the Node\r\n    this.addClasses(Object.keys(objStyles), Node, instance);\r\n\r\n    // removing param\r\n    Node.removeAttribute(type);\r\n  }\r\n};\r\n\r\n// for test with jest\r\nif (typeof exports !== 'undefined' && typeof module !== 'undefined' && module.exports) module.exports = uLayouter;","/**\r\n * Construtor maestro del sistema.\r\n * @constructor\r\n * @property {String} version Muestra la versión actual del sistema\r\n * @param {Object} config Objeto contenedor de las configuraciones.\r\n */\r\nfunction Layouter (config) {\r\n  // validation\r\n  if (!config.hasOwnProperty('breakPoints')) return uLayouter.regError('Configuration Missing', '¡configuration missing! :V');\r\n\r\n  // configs\r\n  this.prefix = config.prefix ? config.prefix + '-' : ''\r\n\r\n  // init setterss\r\n  const bps = config.breakPoints;\r\n  this.breakPoints = bps;\r\n  this.sizes = uLayouter.getNums(bps, 'width');\r\n  this.cols = uLayouter.getNums(bps, 'cols');\r\n  this.scope = uLayouter.createScopesStyles(Object.assign({bridge: true}, config));\r\n  this.styles = {};\r\n  this.debug = config.debug || false;\r\n};\r\n\r\nLayouter.version = '1.10.0RC'\r\n","/**\r\n * Procesa todos los atributos de procesamiento que se tenga disponible\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n */\r\nLayouter.prototype.set = function (Node) {\r\n  if (!Node) return uLayouter.regError('Non-existent Node', \"Don't exists the Node for processing.\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Starting the 'set' of the Node:\",\r\n    data: Node\r\n  });\r\n  const params = this.getParameters(Node);\r\n  const arrParams = Object.keys(params);\r\n  if (!arrParams.length) return uLayouter.regError('Parameter Missing', \"don't exists any parameter to process\");\r\n  const toBuild = {};\r\n  for(let prop in params) toBuild[prop] = params[prop].join(' ');\r\n  const classesObj = this.build(toBuild);\r\n  const classesNames = Object.keys(classesObj)\r\n    .map(function (name) {\r\n      return Object.keys(classesObj[name]).join(' ')\r\n    })\r\n    .join(' ');\r\n  Node.className = Node.className ? Node.className + ' ' + classesNames : classesNames;\r\n  arrParams.forEach(function (nameParam) {\r\n    setTimeout(function (name) {\r\n      Node.removeAttribute(name);\r\n    }, 0, nameParam)\r\n  })\r\n};\r\n\r\n/**\r\n * Procesa un objeto de designaciones que representan los atributos de un Nodo\r\n * @memberof Layouter\r\n * @param {Object} obj Contenedor de los atributos a procesar.\r\n */\r\nLayouter.prototype.build = function (obj) {\r\n  if (!Node) return uLayouter.regError('Non-existent Object', \"Don't exists the object for processing.\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Starting building the attributes:\",\r\n    data: obj\r\n  });\r\n  const rObj = {}, _this = this;\r\n  let propData;\r\n  Object.keys(obj).forEach(function (prop) {\r\n    propData = uLayouter.processors[prop];\r\n    if (propData) rObj[prop] = _this[propData.build](obj[prop])\r\n  });\r\n  return (Object.keys(rObj).length) ? rObj : false;\r\n};\r\n\r\n/**\r\n * Obtiene los parametros disponibles para procesar\r\n * @memberof Layouter\r\n * @param {Object} Nodo Nodo de donde obtener los parametros.\r\n * @returns {Object}\r\n */\r\nLayouter.prototype.getParameters = function (Node) {\r\n  const params = {};\r\n  const attrs = Node.attributes;\r\n  const paramNames = Object.keys(uLayouter.processors);\r\n  Array.prototype.forEach.call(attrs, function (attr) {\r\n    if (paramNames.indexOf(attr.name) !== -1) {\r\n      if (attr.value !== '') params[attr.name] = attr.value.trim().split(' ');\r\n    }\r\n  });\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: 'Getting / Getted parameters of the Node:',\r\n    data: {\r\n      parameters: params,\r\n      node: Node\r\n    }\r\n  });\r\n  return params;\r\n};\r\n\r\n/**\r\n * Remueve las clases de tipo layouter de cualquier nodo pasado\r\n * @memberof Layouter\r\n * @param {Object} Nodo Nodo al cual remover las clases\r\n * @returns {Array} Las clases remover.\r\n */\r\nLayouter.prototype.reset = function (Node) {\r\n  if (!Node) return uLayouter.regError('Non-existent Node', \"Don't exists the Node for processing.\");\r\n  if (!Node.className) {\r\n    uLayouter.debug({\r\n      type: 'i',\r\n      print: this.debug,\r\n      message: \"The Node passed haven't any CSS class\",\r\n      data: Node\r\n    });\r\n    return classesList\r\n  };\r\n  let nPrex, prex;\r\n  const layouterClasses = Object.keys(uLayouter.processors);\r\n  const restClass = [];\r\n  const classList = Node.className.split(' ')\r\n    .filter(function (name) {\r\n      if (name.length < 4) {\r\n        restClass.push(name);\r\n        return false; \r\n      }\r\n      nPrex = name.length >= 5 ? 5 : 4;\r\n      prex = name.substring(0, nPrex);\r\n      let lineIndex = prex.split('').indexOf('-');\r\n      if (lineIndex === -1) {\r\n        restClass.push(name);\r\n        return false;\r\n      }\r\n      prex = prex.substring(0, lineIndex);\r\n      if (layouterClasses.indexOf(prex) !== -1) {\r\n        return true;\r\n      } else {\r\n        restClass.push(name);\r\n        return false;\r\n      }\r\n    });\r\n  if (restClass.length) {\r\n    Node.className = restClass.join(' ');\r\n  } else {\r\n    Node.removeAttribute('class');\r\n  }\r\n  return classList;\r\n};\r\n\r\n/**\r\n * Construye las columnas requeridas, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valCols columnas a procesar\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @returns {Object}\r\n */\r\nLayouter.prototype.buildCols = function (valCols, insertStyles) {\r\n  if (valCols === undefined) return uLayouter.regError('Parameter Missing', \"Don't exists 'cols' determined\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Building the 'cols': \" + valCols,\r\n  });\r\n  const _this = this;\r\n  let cols, bp, bpCals = {};\r\n\r\n  // Getting numbers\r\n  let selectorName, propValue, paramPrepared;\r\n  const bpsObj = this.breakPoints;\r\n  if (!Array.isArray(valCols)) valCols = valCols.split(' ');\r\n  valCols.forEach(function (param) {\r\n    selectorName = param;\r\n    paramPrepared = uLayouter.prepareParam(param, bpsObj);\r\n    bp = paramPrepared.breakPoints;\r\n    param = paramPrepared.numbers;\r\n\r\n    if (param.indexOf('/') !== -1) {\r\n      cols = param.split('/');\r\n    } else {\r\n      if (paramPrepared.widthBp) {\r\n        if (bp.indexOf('-') === -1) {\r\n          cols = [param, _this.cols[bp]];\r\n        } else {\r\n          uLayouter.regError('SyntaxError', \"You can't determine a 'until breakpoint' when use the explicit columns max\");\r\n        }\r\n      } else {\r\n        cols = [param, _this.cols.xs];\r\n      }\r\n    }\r\n    propValue = uLayouter.calPercentage(cols[0], cols[1]);\r\n    if (paramPrepared.important) propValue += ' !important';\r\n\r\n    bpCals[bp] = {\r\n      name: selectorName,\r\n      value: propValue\r\n    };\r\n  });\r\n\r\n  // Building the classNames and the styles to use.\r\n  return uLayouter.buildCss({\r\n    type: 'cols',\r\n    bps: bpCals,\r\n    instance: this,\r\n    deep: (insertStyles === undefined ? true : insertStyles)\r\n  });\r\n};\r\n\r\n/**\r\n * Asigna los estilos necesarios a un nodo referentes a las columnas determinadas\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo a donde asignar los estilos\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setCols = function (Node, parameters) {\r\n  if (!Node) return uLayouter.regError('Non-existent Node', \"Don't exists the Node for processing.\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Processing the 'cols' to the Node:\",\r\n    data: Node\r\n  });\r\n  const params = parameters || this.getParameters(Node);\r\n  if (!params.hasOwnProperty('cols')) return uLayouter.regError('Parameter Missing', \"Don't exists 'cols' determined\");\r\n\r\n  // Creating, inserting, and adding classNames of rules in Node.\r\n  const objStyles = this.buildCols(params.cols);\r\n\r\n  // adding the classes names to the Node\r\n  uLayouter.addClasses(Object.keys(objStyles), Node, this);\r\n\r\n  // removing param\r\n  Node.removeAttribute('cols');\r\n};\r\n\r\n/**\r\n * Construye los paddings requeridas, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valPads Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildPads = function (valPads, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valPads, 'pad', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea los paddings necesarios para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setPads = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'pad', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el padding superior, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valPad Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildPadTop = function (valPad, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valPad, 'padt', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el padding top necesario para un nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setPadTop = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'padt', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el padding derecho, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valPad Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildPadRight = function (valPad, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valPad, 'padr', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el padding right necesario para un nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setPadRight = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'padr', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el padding inferior, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valPad Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildPadBottom = function (valPad, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valPad, 'padb', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el padding bottom necesario para un nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setPadBottom = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'padb', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el padding izquierdo, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valPad Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildPadLeft = function (valPad, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valPad, 'padl', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el padding left necesario para un nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setPadLeft = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'padl', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye los margenes, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMars Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMars = function (valMars, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valMars, 'mar', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea los margins necesarios para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMars = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'mar', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el margen superior, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMar Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMarTop = function (valMar, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valMar, 'mart', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el margin top necesario para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMarTop = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'mart', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el margen derecho, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMar Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMarRight = function (valMar, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valMar, 'marr', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el margin right necesario para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMarRight = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'marr', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el margen inferior, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMar Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMarBottom = function (valMar, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valMar, 'marb', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el margin bottom necesario para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMarBottom = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'marb', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el margen inferior, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMar Paddings a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMarLeft = function (valMar, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valMar, 'marl', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el margin left necesario para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMarLeft = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'marl', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye las reglas CSS y nombre de clases referente al 'flex'.\r\n * @memberof Layouter\r\n * @param {String} valFlex columnas a procesar\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @returns {Object}\r\n */\r\nLayouter.prototype.buildFlex = function (valFlex, insertStyles) {\r\n  if (valFlex === undefined) return uLayouter.regError('Parameter Missing', \"Don't exists 'flex' determined\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Building the 'flex': \" + valFlex,\r\n  });\r\n  let bpNameS, bpCals = {};\r\n\r\n  // Getting numbers\r\n  let selectorName, paramPrepared, flexSplited,  propVal, nameProp, valProp;\r\n  if (!Array.isArray(valFlex)) valFlex = valFlex.split(' ');\r\n  const bpsObj = this.breakPoints;\r\n  valFlex.forEach(function (param) {\r\n    selectorName = param;\r\n\r\n    paramPrepared = uLayouter.prepareParam(param, bpsObj);\r\n    bpNameS = paramPrepared.breakPoints;\r\n    param = paramPrepared.numbers;\r\n\r\n    flexSplited = param.split(':');\r\n    nameProp = flexSplited[0];\r\n    valProp = flexSplited[1];\r\n    if (uLayouter.flexAttrsSelf.indexOf(nameProp) === -1) { // ignoring the flex attrs selfs\r\n      if (uLayouter.flexpv.hasOwnProperty(nameProp)) {\r\n        if (uLayouter.flexpv.hasOwnProperty(valProp)) {\r\n          propVal = uLayouter.flexpv[nameProp] + ':' + uLayouter.flexpv[valProp];\r\n        } else {\r\n          return uLayouter.regError('Non-existent Alias', \"Don't exists the alias '\" + valProp + \"' in Flex vault.\");\r\n        }\r\n      } else {\r\n        return uLayouter.regError('Non-existent Alias', \"Don't exists the alias '\" + nameProp + \"' in Flex vault.\");\r\n      }\r\n    } else {\r\n      propVal = uLayouter.flexpv[nameProp] + ':' + valProp;\r\n    }\r\n\r\n    if (paramPrepared.important) propVal += ' !important';\r\n\r\n    if (bpCals.hasOwnProperty(bpNameS)) {\r\n      if (selectorName.indexOf('@') !== 1) selectorName = selectorName.split('@')[0];\r\n      bpCals[bpNameS].name = bpCals[bpNameS].name.split('@')[0] + '-' + selectorName + '@' + bpNameS;\r\n      bpCals[bpNameS].value += ';' + propVal;\r\n    } else {\r\n      bpCals[bpNameS] = {\r\n        name: selectorName,\r\n        value: propVal\r\n      };\r\n    }\r\n  });\r\n\r\n  // Building the classNames and the styles to use.\r\n  return uLayouter.buildCss({\r\n    type: 'flex',\r\n    bps: bpCals,\r\n    instance: this,\r\n    deep: (insertStyles === undefined ? true : insertStyles)\r\n  });\r\n};\r\n\r\n/**\r\n * Setea la propiedad Flex y las reglas designadas\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setFlex = function (Node, parameters) {\r\n  if (!Node) return uLayouter.regError('Non-existent Node', \"Don't exists the Node for processing.\");\r\n  uLayouter.debug({\r\n    type: 'i',\r\n    print: this.debug,\r\n    message: \"Processing the 'flex' parameter to the Node:\",\r\n    data: Node\r\n  });\r\n  const params = parameters || this.getParameters(Node);\r\n  if (!params.hasOwnProperty('flex')) return uLayouter.regError('Parameter Missing', \"Don't exists 'flex' determinated.\");\r\n\r\n  // Creating, inserting, and adding classNames of rules in Node.\r\n  const objStyles = this.buildFlex(params.flex);\r\n\r\n  // adding the classes names to the Node\r\n  uLayouter.addClasses(Object.keys(objStyles), Node, this);\r\n\r\n  // removing param\r\n  Node.removeAttribute('flex');\r\n};\r\n\r\n/**\r\n * Construye el máximo ancho, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMxw máximo ancho a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMaxWidth = function (valMxw, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valMxw, 'mw', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el máximo ancho necesario para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMaxWidth = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'mw', parameters, this);\r\n};\r\n\r\n/**\r\n * Construye el máximo alto, devolviendo el nombre de clase y los estilos creados.\r\n * @memberof Layouter\r\n * @param {String} valMxh máximo alto a construir\r\n * @param {Boolean} [insertStyles] Indica si se vá o no procesar en el navegador la regla css para ser usada.\r\n * @return {Object}\r\n */\r\nLayouter.prototype.buildMaxHeight = function (valMxh, insertStyles) {\r\n  return uLayouter.buildPadsMargsMaxs(valMxh, 'mh', this, insertStyles);\r\n};\r\n\r\n/**\r\n * Setea el máximo alto necesario para un Nodo.\r\n * @memberof Layouter\r\n * @param {Object} Node Nodo vivo del DOM a asignarle el CSS\r\n * @param {Object} [parameters] Parametros obtenidos del nodo.\r\n */\r\nLayouter.prototype.setMaxHeight = function (Node, parameters) {\r\n  uLayouter.setPadsMargsMaxs(Node, 'mh', parameters, this);\r\n};"]}